#!/usr/bin/env bash
# Configure machine-specific Git settings
# Uses SSH signing (recommended over GPG - simpler, uses existing SSH keys)
#
# - Imports SSH keys from GitHub
# - Detects 1Password SSH agent or falls back to ssh-keygen
# - Generates .gitconfig.local with SSH signing configuration
#
# SSH signing advantages over GPG:
# - No GPG keyring to manage
# - Uses the same SSH key you already use for GitHub
# - 1Password integration provides secure key storage
# - Simpler setup and maintenance

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
GITCONFIG_LOCAL="$HOME/.gitconfig.local"
SSH_DIR="$HOME/.ssh"
ONEPASSWORD_SIGN="/opt/1Password/op-ssh-sign"
FALLBACK_SIGN="/usr/bin/ssh-keygen"

# Print colored output
print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Get GitHub username
get_github_username() {
    local username=""

    if [ $# -gt 0 ]; then
        username="$1"
    else
        read -rp "Enter your GitHub username: " username
    fi

    echo "$username"
}

# Import SSH keys from GitHub
import_github_keys() {
    local username="$1"

    mkdir -p "$SSH_DIR"
    chmod 700 "$SSH_DIR"

    print_info "Importing SSH keys from GitHub for user: $username"
    local keys
    keys="$(curl -sS "https://github.com/${username}.keys")" || {
        print_error "Failed to fetch SSH keys from GitHub"
        exit 1
    }

    if [[ -z "$keys" ]]; then
        print_error "No SSH keys found for GitHub user: $username"
        exit 1
    fi

    # Append to authorized_keys, avoiding duplicates
    local auth_keys="$SSH_DIR/authorized_keys"
    touch "$auth_keys"
    chmod 600 "$auth_keys"

    local added=0
    while IFS= read -r key; do
        if ! grep -qF "$key" "$auth_keys" 2>/dev/null; then
            echo "$key" >> "$auth_keys"
            ((added++))
        fi
    done <<< "$keys"

    print_success "SSH keys imported ($added new, from GitHub)"
}

# Get the first ed25519 key from authorized_keys
get_signing_key() {
    local auth_keys="$SSH_DIR/authorized_keys"

    if [ ! -f "$auth_keys" ]; then
        print_error "No authorized_keys file found at $auth_keys"
        exit 1
    fi

    # Find first ed25519 key
    local key
    key=$(grep "ssh-ed25519" "$auth_keys" | head -n1)

    if [ -z "$key" ]; then
        print_warning "No ed25519 key found, trying rsa..."
        key=$(grep "ssh-rsa" "$auth_keys" | head -n1)
    fi

    if [ -z "$key" ]; then
        print_error "No suitable SSH key found in $auth_keys"
        exit 1
    fi

    # Extract only key type and key data (remove comment)
    # Format: "ssh-ed25519 AAAAA... [optional comment]"
    # We want: "ssh-ed25519 AAAAA..."
    echo "$key" | awk '{print $1 " " $2}'
}

# Detect GPG signing program
detect_gpg_program() {
    if [ -f "$ONEPASSWORD_SIGN" ]; then
        print_success "1Password detected at $ONEPASSWORD_SIGN" >&2
        echo "$ONEPASSWORD_SIGN"
    elif [ -f "$FALLBACK_SIGN" ]; then
        print_warning "1Password not found, using fallback: $FALLBACK_SIGN" >&2
        echo "$FALLBACK_SIGN"
    else
        print_error "Neither 1Password nor ssh-keygen found"
        exit 1
    fi
}

# Generate .gitconfig.local
generate_gitconfig_local() {
    local signing_key="$1"
    local gpg_program="$2"

    print_info "Generating $GITCONFIG_LOCAL..."

    cat > "$GITCONFIG_LOCAL" << EOF
# Machine-specific Git Configuration
# Generated by configure-git-machine on $(date +%Y-%m-%d)
# This file is NOT version controlled in dotfiles

[user]
    signingKey = $signing_key

[gpg]
    format = ssh

[gpg "ssh"]
    program = $gpg_program
EOF

    # Add fallback comment if using 1Password
    if [[ "$gpg_program" == "$ONEPASSWORD_SIGN" ]]; then
        cat >> "$GITCONFIG_LOCAL" << EOF
    # Fallback for machines without 1Password
    # program = $FALLBACK_SIGN
EOF
    fi

    print_success "Configuration written to $GITCONFIG_LOCAL"
}

# Backup existing config
backup_existing_config() {
    if [ -f "$GITCONFIG_LOCAL" ]; then
        local backup="${GITCONFIG_LOCAL}.backup.$(date +%Y%m%d_%H%M%S)"
        print_warning "Backing up existing config to $backup"
        cp "$GITCONFIG_LOCAL" "$backup"
    fi
}

# Verify configuration
verify_config() {
    print_info "Verifying Git configuration..."

    echo ""
    echo "Current Git signing configuration:"
    git config --get user.signingkey && print_success "Signing key: $(git config --get user.signingkey)" || print_warning "No signing key configured"
    git config --get gpg.format && print_success "GPG format: $(git config --get gpg.format)" || print_warning "No GPG format configured"
    git config --get gpg.ssh.program && print_success "GPG SSH program: $(git config --get gpg.ssh.program)" || print_warning "No GPG SSH program configured"
    echo ""
}

# Main function
main() {
    echo ""
    print_info "Git Machine Configuration Script"
    echo ""

    # Get GitHub username
    local github_username
    github_username=$(get_github_username "$@")

    # Backup existing config
    backup_existing_config

    # Import SSH keys from GitHub
    import_github_keys "$github_username"

    # Get signing key
    print_info "Extracting signing key..."
    local signing_key
    signing_key=$(get_signing_key)
    print_success "Found signing key: ${signing_key:0:50}..."

    # Detect GPG program
    local gpg_program
    gpg_program=$(detect_gpg_program)

    # Generate config
    generate_gitconfig_local "$signing_key" "$gpg_program"

    # Verify
    verify_config

    print_success "Git machine configuration complete!"
    echo ""
    print_info "You can now sign commits with: git commit -S"
    print_info "To test signing: git commit --allow-empty -m 'Test signed commit'"
    echo ""
}

# Run main function with all arguments
main "$@"
