#!/usr/bin/env bash
# configure-git-machine — set up machine-specific git identity and SSH signing
#
# Usage: configure-git-machine <github_username>
#
# Pipeline:
#   1. Fetch user identity from GitHub API
#   2. Fetch SSH public keys from GitHub
#   3. Detect 1Password SSH agent (cross-platform)
#   4. Generate ~/.gitconfig.local (backup existing)
#   5. Update ~/.ssh/allowed_signers (append-only)

set -euo pipefail

# ── colours ──────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

info()    { echo -e "${BLUE}::${NC} $*"; }
ok()      { echo -e "${GREEN}✓${NC}  $*"; }
warn()    { echo -e "${YELLOW}!${NC}  $*"; }
err()     { echo -e "${RED}✗${NC}  $*" >&2; }
die()     { err "$@"; exit 1; }

# ── configuration ────────────────────────────────────────────────────
GITCONFIG_LOCAL="$HOME/.gitconfig.local"
ALLOWED_SIGNERS="$HOME/.ssh/allowed_signers"

# 1Password socket paths (platform-specific)
OP_SOCK_LINUX="$HOME/.1password/agent.sock"
OP_SOCK_MACOS="$HOME/Library/Group Containers/2BUA8C4S2C.com.1password/t/agent.sock"

# 1Password signing program paths
OP_SIGN_LINUX="/opt/1Password/op-ssh-sign"
OP_SIGN_MACOS="/Applications/1Password.app/Contents/MacOS/op-ssh-sign"

FALLBACK_SIGN="/usr/bin/ssh-keygen"

# ── helpers ──────────────────────────────────────────────────────────
need_cmd() {
    command -v "$1" >/dev/null 2>&1 || die "Required command not found: $1"
}

detect_platform() {
    case "$(uname -s)" in
        Linux*)  echo "linux" ;;
        Darwin*) echo "macos" ;;
        *)       die "Unsupported platform: $(uname -s)" ;;
    esac
}

# ── pipeline steps ───────────────────────────────────────────────────

# Step 1: Fetch identity from GitHub API
fetch_identity() {
    local username="$1"
    info "Fetching identity for GitHub user: ${BOLD}$username${NC}"

    local api_response
    api_response=$(curl -sf "https://api.github.com/users/${username}") \
        || die "Failed to fetch GitHub user: $username"

    # Extract name — try jq first, fall back to grep
    if command -v jq >/dev/null 2>&1; then
        GIT_NAME=$(echo "$api_response" | jq -r '.name // empty')
    else
        GIT_NAME=$(echo "$api_response" | grep -oP '"name"\s*:\s*"\K[^"]+' || true)
    fi

    if [[ -z "$GIT_NAME" ]]; then
        die "GitHub user '$username' has no public name set"
    fi

    GIT_EMAIL="${username}@users.noreply.github.com"

    ok "Name:  $GIT_NAME"
    ok "Email: $GIT_EMAIL"
}

# Step 2: Fetch SSH keys from GitHub
fetch_keys() {
    local username="$1"
    info "Fetching SSH keys from github.com/${username}.keys"

    GITHUB_KEYS=$(curl -sf "https://github.com/${username}.keys") \
        || die "Failed to fetch SSH keys for: $username"

    if [[ -z "$GITHUB_KEYS" ]]; then
        die "No SSH keys found for GitHub user: $username"
    fi

    local key_count
    key_count=$(echo "$GITHUB_KEYS" | wc -l)
    ok "Found $key_count key(s)"

    # Pick signing key: prefer ed25519, fall back to first key
    SIGNING_KEY=$(echo "$GITHUB_KEYS" | grep "ssh-ed25519" | head -n1 || true)
    if [[ -z "$SIGNING_KEY" ]]; then
        warn "No ed25519 key found, using first available key"
        SIGNING_KEY=$(echo "$GITHUB_KEYS" | head -n1)
    fi

    # Strip trailing comment (keep "type base64" only)
    SIGNING_KEY=$(echo "$SIGNING_KEY" | awk '{print $1, $2}')

    ok "Signing key: ${SIGNING_KEY:0:50}..."
}

# Step 3: Detect 1Password SSH agent
detect_1password() {
    local platform="$1"
    info "Detecting 1Password SSH agent..."

    local op_sock op_sign
    if [[ "$platform" == "macos" ]]; then
        op_sock="$OP_SOCK_MACOS"
        op_sign="$OP_SIGN_MACOS"
    else
        op_sock="$OP_SOCK_LINUX"
        op_sign="$OP_SIGN_LINUX"
    fi

    if [[ -S "$op_sock" ]]; then
        ok "1Password agent socket found: $op_sock"
        if [[ -x "$op_sign" ]]; then
            GPG_SSH_PROGRAM="$op_sign"
            ok "Signing program: $GPG_SSH_PROGRAM"
        else
            warn "1Password socket exists but op-ssh-sign not found at $op_sign"
            warn "Falling back to $FALLBACK_SIGN"
            GPG_SSH_PROGRAM="$FALLBACK_SIGN"
        fi
    else
        warn "No 1Password agent socket at $op_sock"
        GPG_SSH_PROGRAM="$FALLBACK_SIGN"
        ok "Using fallback: $GPG_SSH_PROGRAM"
    fi
}

# Step 4: Generate ~/.gitconfig.local
generate_gitconfig_local() {
    info "Generating $GITCONFIG_LOCAL"

    # Backup existing
    if [[ -f "$GITCONFIG_LOCAL" ]]; then
        local backup="${GITCONFIG_LOCAL}.bak.$(date +%Y%m%d_%H%M%S)"
        cp "$GITCONFIG_LOCAL" "$backup"
        warn "Backed up existing → $backup"
    fi

    cat > "$GITCONFIG_LOCAL" << EOF
# Machine-specific Git configuration
# Generated by configure-git-machine on $(date +%Y-%m-%d)
# Do NOT check this file into version control.

[user]
    name = $GIT_NAME
    email = $GIT_EMAIL
    signingKey = $SIGNING_KEY

[gpg]
    format = ssh

[gpg "ssh"]
    program = $GPG_SSH_PROGRAM
    allowedSignersFile = $ALLOWED_SIGNERS
EOF

    ok "Written to $GITCONFIG_LOCAL"
}

# Step 5: Update allowed_signers (append-only)
update_allowed_signers() {
    local username="$1"
    info "Updating $ALLOWED_SIGNERS"

    mkdir -p "$(dirname "$ALLOWED_SIGNERS")"
    touch "$ALLOWED_SIGNERS"

    local added=0
    while IFS= read -r key; do
        [[ -z "$key" ]] && continue
        # Check if the key material (type + base64) already exists in the file
        local key_material
        key_material=$(echo "$key" | awk '{print $1, $2}')
        if ! grep -qF "$key_material" "$ALLOWED_SIGNERS" 2>/dev/null; then
            echo "$username $key_material" >> "$ALLOWED_SIGNERS"
            added=$((added + 1))
        fi
    done <<< "$GITHUB_KEYS"

    ok "Allowed signers updated ($added new key(s) added)"
}

# ── main ─────────────────────────────────────────────────────────────
main() {
    if [[ $# -ne 1 ]]; then
        echo "Usage: configure-git-machine <github_username>"
        exit 1
    fi

    local username="$1"
    local platform

    echo ""
    info "${BOLD}Git Machine Configuration${NC}"
    echo ""

    need_cmd curl
    need_cmd git

    platform=$(detect_platform)
    ok "Platform: $platform"
    echo ""

    fetch_identity "$username"
    echo ""

    fetch_keys "$username"
    echo ""

    detect_1password "$platform"
    echo ""

    generate_gitconfig_local
    echo ""

    update_allowed_signers "$username"
    echo ""

    info "${BOLD}Configuration complete!${NC}"
    echo ""
    info "Verify with:  git-setup-verify"
    info "Test commit:  git commit --allow-empty -m 'test: verify SSH signing'"
    echo ""
}

main "$@"
